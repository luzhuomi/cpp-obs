## Benchmark


We compare the two control flow obfuscation techniques, namely CPS and
CFF, by measuring the size of the resulting source files and object
files as well as the run times of the application.

### File size explosion

|    | CFF (src) | CPS (src) | CFF (obj) | CPS (obj)  |
--------------------------------------
|  fib | 1.04  | 1.31 | 1 | 1.2  |
|    sort | 1.09  | 1.45 | 1 | 1.9  |
|    linklist | 1.62  | 6.27  | 1.31 | 7.92  |
|    bst |  1.52  | 4.65 | 1.31 | 5.46  |
|    md5 | 1.41 | 1.84 | 1.88 | 6.66  |
|    jpeg2ps | 1.25 | 2.08 | 1.18 | 4.9  |
|    python2/ast | 1.54  | 5.57 | 1.62 | 31.56  |
|    pigz/deflate | 2.75  | 8.94 | 0.55 | 18.95  |
|    pigz/lz77 |  1.98 | 6.17 | 1.6 | 21.67  |
|    ffmpeg/flvenc | 1.04 | 1.32 | 1.07 | 2.75  |


In the above table, we examine the file size growth by
measuring the file size ratios before and after the obfuscation.
The list of benchmark suite consists of hand-crafted examples such as
fib and sort, C tutorial examples linklist and ast collected from
http://www.zentut.com/c-tutorial/,  real-world application, python2/ast, pigz/deflate and
pigz/lz77. 
The source code growth (src) ratios are computed by taking the file
sizes after obfuscation divided the sizes 
before obfuscation (after pre-processing phase). The object code grow
(obj) ratios are measured the .o files. 
The pre-processing and object file compilation are generated using gcc (Apple LLVM
version 9.1.0). As we observe from the benchmarks, obfuscation through continuation
passing style yields a higher code/object file increase compared to
control flow flattening. 

### Run time overhead


|           | md5 | jpeg2ps | python2 | pigz | ffmpeg |
--------------------------------------
|    CFF | 1.04 | 1            | 1.01       | 1.08 | 1.01     |
|    CPS | 2.11 | 1.1         | 1.06       | 1.22 | 1.03     |
In the aboe table, we report the run-time overhead incurred
by the two obfuscation techniques. The benchmarks are collected from
a Mac Pro with Intel XEON E5 processors. The run times are measured the user
time generated by time command. 
The run time of the python2/ast test case is measured by executing the generated
python binary with a sodoku python source code and the flag  -m
  py_compile.  The run-time of the pigz/deflate test case is
measured by running pigz binary to compress a 3.5MB text file
with the flag "-11".  The run-time of the ffmpeg test case is
measured by running a mp4 to flv conversion with a 151MB file. 
The numbers listed in the table denote the
ratios between the run-time taken from the obfuscated code and the one taken
from the original (unobfuscated) versions. As observed, CFF obfuscation generates a
slightly smaller overhead compared to CPS. In most
cases the overheads do not exceed 25%.  We note that CPS
incurs additional overhead such as the space required for the call stack. In case of md5, 
the CPS obfuscated binary yields a stack overflow
given a large size input.
